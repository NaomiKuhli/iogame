<!doctype html>
<html lang="de">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <title>Tank.io</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: Arial, sans-serif;
                overflow: hidden;
            }

            #loading {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 20px;
                border-radius: 10px;
                font-size: 24px;
                z-index: 5;
            }

            canvas {
                display: block;
            }

            /* Improved Minimap - smaller for mobile */
            #minimap-container {
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.2);
                padding: 3px;
                border-radius: 3px;
                transform-origin: top left;
                z-index: 5;
            }
            
            /* Scale minimap differently on mobile */
            @media (max-width: 767px) {
                #minimap-container {
                    transform: scale(0.8);
                }
                #minimap-canvas {
                    width: 120px !important;
                    height: 120px !important;
                }
            }

            #debug-info {
                position: absolute;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.6);
                color: white;
                padding: 5px 10px;
                border-radius: 5px;
                font-size: 12px;
                display: none;
            }

            /* Improved Leaderboard - smaller and more transparent for mobile */
            #leaderboard {
                position: absolute;
                top: 10px;
                right: 10px;
                width: 180px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 5px;
                padding: 6px;
                color: white;
                transform-origin: top right;
                z-index: 5;
            }
            
            /* Scale leaderboard for mobile */
            @media (max-width: 767px) {
                #leaderboard {
                    transform: scale(0.8);
                    width: 150px;
                }
            }

            .leaderboard-title {
                text-align: center;
                margin-top: 0;
                margin-bottom: 5px;
                font-size: 14px;
            }

            .leaderboard-item {
                display: flex;
                justify-content: space-between;
                margin-bottom: 3px;
                font-size: 12px;
            }

            .leaderboard-name {
                max-width: 110px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .crown {
                color: gold;
                margin-right: 5px;
            }

            /* XP-Bar Styling - adjusted position for mobile */
            #xp-bar-container {
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 20px;
                background: none;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 4;
            }

            #xp-bar-wrapper {
                width: 70%;
                height: 14px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 7px;
                overflow: hidden;
                position: relative;
            }

            #xp-bar {
                height: 100%;
                width: 0%;
                background: linear-gradient(to bottom, #4CAF50, #2E7D32);
                transition: width 0.3s ease;
            }

            #xp-text {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 10px;
                font-weight: bold;
                text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            }

            #particle-canvas {
                position: absolute;
                top: 0;
                left: 0;
                pointer-events: none;
                z-index: 10;
            }

            /* NEUE STYLE-REGELN F√úR UPGRADES UND UI - kompakter f√ºr mobile */
            .level-number {
                display: inline-block;
                background-color: #3498db;
                color: white;
                font-size: 10px;
                width: 16px;
                height: 16px;
                line-height: 16px;
                text-align: center;
                border-radius: 8px;
                margin-left: 4px;
                font-weight: bold;
            }

            /* Farbverlauf f√ºr die Upgrade-Balken */
            .level-filled {
                height: 100%;
                background: linear-gradient(to right, #3498db, #2ecc71);
                border-radius: 5px;
                transition: width 0.3s ease;
            }

            /* Verbesserte Upgrade-Buttons */
            .upgrade-button {
                width: 24px;
                height: 18px;
                line-height: 18px;
                text-align: center;
                background: #3498db;
                border-radius: 3px;
                cursor: pointer;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            }

            .upgrade-button:hover {
                background: #2980b9;
                transform: scale(1.05);
            }

            .upgrade-button.disabled {
                background: #555;
                cursor: not-allowed;
                box-shadow: none;
                transform: none;
            }

            /* Verbessertes Upgrade-Item */
            .upgrade-item {
                margin-bottom: 6px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 2px;
                border-radius: 4px;
                transition: background-color 0.2s ease;
            }

            .upgrade-item:hover {
                background-color: rgba(255, 255, 255, 0.1);
            }

            .upgrade-name {
                display: inline-block;
                width: 110px;
                font-size: 12px;
            }

            /* Verbesserte Level-Leiste */
            .level-indicator {
                display: inline-block;
                width: 60px;
                height: 8px;
                background: #333;
                margin-right: 8px;
                border-radius: 4px;
                overflow: hidden;
                box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            }

            /* Verbessertes Upgrade-Men√º */
            #upgrade-menu {
                position: absolute;
                left: 10px;
                bottom: 28px;
                width: 210px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 8px;
                padding: 8px;
                color: white;
                display: none;
                font-size: 11px;
                backdrop-filter: blur(5px);
                box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.1);
                z-index: 4;
                transform-origin: bottom left;
            }

            /* Scale upgrade menu on mobile */
            @media (max-width: 767px) {
                #upgrade-menu {
                    transform: scale(0.85);
                    bottom: 170px;
                }
            }

            #upgrade-status {
                margin-top: 8px;
                font-size: 11px;
                text-align: center;
                padding: 3px;
                background: rgba(0,0,0,0.2);
                border-radius: 4px;
            }

            /* Death screen adjustments for mobile */
            #death-screen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
                display: none;
            }

            #death-screen .death-content {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                color: white;
                width: 90%;
                max-width: 500px;
            }

            #death-title {
                font-size: 22px;
                margin-bottom: 5px;
            }

            #death-killer {
                font-size: 28px;
                color: #f39c12;
                margin-top: 5px;
                margin-bottom: 15px;
            }

            #death-stats {
                background: rgba(0, 0, 0, 0.6);
                padding: 15px;
                border-radius: 10px;
                margin-bottom: 15px;
            }

            .death-stat-row {
                display: flex;
                justify-content: space-between;
                margin-bottom: 8px;
            }

            .death-stat-label, .death-stat-value {
                font-weight: bold;
                font-size: 16px;
            }

            #death-achievement {
                display: none;
                background: rgba(231, 76, 60, 0.8);
                padding: 10px;
                border-radius: 8px;
                margin-bottom: 20px;
            }

            #death-achievement-title {
                font-weight: bold;
                font-size: 14px;
                margin-bottom: 5px;
            }

            #death-continue-btn {
                background: #3498db;
                border: none;
                color: white;
                padding: 10px 30px;
                font-size: 18px;
                border-radius: 5px;
                cursor: pointer;
                transition: background 0.2s;
            }

            #death-continue-btn:hover {
                background: #2980b9;
            }

            /* Styling f√ºr Missionen im Death Screen */
            .death-mission-item {
                background: rgba(0, 0, 0, 0.3);
                padding: 6px 10px;
                margin-bottom: 6px;
                border-radius: 5px;
                text-align: left;
            }

            .death-mission-progress {
                display: flex;
                align-items: center;
                margin-top: 4px;
            }

            .death-mission-bar {
                flex-grow: 1;
                height: 6px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 3px;
                margin-right: 8px;
                overflow: hidden;
            }

            .death-mission-fill {
                height: 100%;
                background: #3498db;
                width: 0%;
            }

            .death-mission-complete .death-mission-fill {
                background: #2ecc71;
            }

            .death-mission-status {
                font-size: 11px;
                color: white;
                min-width: 50px;
                text-align: right;
            }

            .death-mission-reward {
                color: gold;
                font-weight: bold;
            }

            /* Coins-Anzeige im Death Screen */
            .coin-icon {
                color: gold;
                margin-right: 5px;
            }

            .death-coins-earned {
                color: #f1c40f;
                font-size: 22px;
                font-weight: bold;
                margin: 12px 0;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            /* IMPROVED MOBILE CONTROLS */
            .mobile-controls {
                display: none; /* Standardm√§√üig ausgeblendet */
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 35%;
                z-index: 100;
                pointer-events: none; /* Erlaubt Events, die durch diese Ebene gehen */
            }

            /* Left joystick for movement */
            .joystick-area {
                position: absolute;
                bottom: 20px;
                left: 20px;
                width: 130px;
                height: 130px;
                background-color: rgba(255, 255, 255, 0.08);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                pointer-events: auto; /* F√§ngt Events ab */
                touch-action: none; /* Verhindert Standard-Touch-Aktionen */
            }

            .joystick-thumb {
                position: absolute;
                width: 50px;
                height: 50px;
                background-color: rgba(255, 255, 255, 0.3);
                border: 2px solid rgba(255, 255, 255, 0.5);
                border-radius: 50%;
                left: 40px;
                top: 40px;
                pointer-events: none; /* Ignoriert Events */
            }

            /* Right area for aiming/firing */
            .fire-area {
                position: absolute;
                bottom: 20px;
                right: 20px;
                width: 130px;
                height: 130px;
                background-color: rgba(255, 255, 255, 0.08);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                pointer-events: auto; /* F√§ngt Events ab */
                touch-action: none; /* Verhindert Standard-Touch-Aktionen */
            }

            .fire-button {
                position: absolute;
                width: 50px;
                height: 50px;
                background-color: rgba(255, 0, 0, 0.3);
                border: 2px solid rgba(255, 50, 50, 0.5);
                border-radius: 50%;
                left: 40px;
                top: 40px;
                pointer-events: none; /* Ignoriert Events */
            }

            .fire-lines {
                position: absolute;
                width: 100%;
                height: 100%;
                border-radius: 50%;
            }

            .fire-lines::before,
            .fire-lines::after {
                content: '';
                position: absolute;
                background-color: rgba(255, 255, 255, 0.5);
            }

            .fire-lines::before {
                width: 2px;
                height: 100%;
                left: 50%;
                top: 0;
                transform: translateX(-50%);
            }

            .fire-lines::after {
                width: 100%;
                height: 2px;
                left: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            /* Auto-fire button */
            .auto-fire-btn {
                position: absolute;
                top: 20px;
                right: 20px;
                width: 50px;
                height: 50px;
                background-color: rgba(255, 0, 0, 0.2);
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 11px;
                text-align: center;
                pointer-events: auto;
            }
            
            .auto-fire-btn.active {
                background-color: rgba(255, 0, 0, 0.5);
                border-color: rgba(255, 255, 255, 0.7);
            }

            /* F√ºr Tablets und gr√∂√üere Bildschirme anpassen */
            @media (min-width: 768px) and (max-width: 1024px) {
                .joystick-area, .fire-area {
                    width: 120px;
                    height: 120px;
                }
                
                .joystick-thumb, .fire-button {
                    width: 48px;
                    height: 48px;
                    left: 36px;
                    top: 36px;
                }
            }

            /* Verhindern des Scrollens auf mobilen Ger√§ten */
            html, body {
                position: fixed;
                overflow: hidden;
                width: 100%;
                height: 100%;
            }

            /* F√ºr den Tod-Bildschirm: Steuerungen ausblenden */
            .controls-hidden .mobile-controls {
                display: none !important;
            }

            /* XP-Bar Anpassung f√ºr mobile Ger√§te */
            @media (max-width: 767px) {
                #xp-bar-container {
                    bottom: 145px;
                    height: 16px;
                }
                
                #xp-bar-wrapper {
                    width: 80%;
                    height: 12px;
                }
                
                #xp-text {
                    font-size: 8px;
                }
            }
        </style>
    </head>
    <body>
        <div id="loading">Spiel wird geladen...</div>
        <canvas id="game-canvas"></canvas>
        <canvas id="particle-canvas"></canvas>
        <div id="minimap-container">
            <canvas id="minimap-canvas" width="150" height="150" style="border: 1px solid #fff"></canvas>
        </div>
        <div id="debug-info"></div>

        <!-- Leaderboard -->
        <div id="leaderboard">
            <h3 class="leaderboard-title">Leaderboard</h3>
            <div id="leaderboard-items">
                <!-- Wird dynamisch bef√ºllt -->
            </div>
            <div id="players-count" style="text-align: right; margin-top: 2px; font-size: 9px; color: #aaa;">Spieler: 1</div>
        </div>

        <!-- XP-Bar (Diep.io Style) -->
        <div id="xp-bar-container">
            <div id="xp-bar-wrapper">
                <div id="xp-bar"></div>
                <div id="xp-text">Level 1 - 0/30 XP</div>
            </div>
        </div>

        <!-- Upgrade-Men√º mit verbesserten Level-Anzeigen -->
        <div id="upgrade-menu">
            <h3 style="margin-top: 0; text-align: center; font-size: 13px;">Upgrades</h3>
            <div class="upgrade-item">
                <span class="upgrade-name">Health Regen <span class="level-number" id="healthRegen-number">1</span></span>
                <div class="level-indicator"><div class="level-filled" id="healthRegen-level" style="width: 10%;"></div></div>
                <div class="upgrade-button" id="healthRegen-btn">+</div>
            </div>
            <div class="upgrade-item">
                <span class="upgrade-name">Max Health <span class="level-number" id="maxHealth-number">1</span></span>
                <div class="level-indicator"><div class="level-filled" id="maxHealth-level" style="width: 10%;"></div></div>
                <div class="upgrade-button" id="maxHealth-btn">+</div>
            </div>
            <div class="upgrade-item">
                <span class="upgrade-name">Body Damage <span class="level-number" id="bodyDamage-number">1</span></span>
                <div class="level-indicator"><div class="level-filled" id="bodyDamage-level" style="width: 10%;"></div></div>
                <div class="upgrade-button" id="bodyDamage-btn">+</div>
            </div>
            <div class="upgrade-item">
                <span class="upgrade-name">Bullet Speed <span class="level-number" id="bulletSpeed-number">1</span></span>
                <div class="level-indicator"><div class="level-filled" id="bulletSpeed-level" style="width: 10%;"></div></div>
                <div class="upgrade-button" id="bulletSpeed-btn">+</div>
            </div>
            <div class="upgrade-item">
                <span class="upgrade-name">Bullet Penetration <span class="level-number" id="bulletPenetration-number">1</span></span>
                <div class="level-indicator"><div class="level-filled" id="bulletPenetration-level" style="width: 10%;"></div></div>
                <div class="upgrade-button" id="bulletPenetration-btn">+</div>
            </div>
            <div class="upgrade-item">
                <span class="upgrade-name">Bullet Damage <span class="level-number" id="bulletDamage-number">1</span></span>
                <div class="level-indicator"><div class="level-filled" id="bulletDamage-level" style="width: 10%;"></div></div>
                <div class="upgrade-button" id="bulletDamage-btn">+</div>
            </div>
            <div class="upgrade-item">
                <span class="upgrade-name">Reload <span class="level-number" id="reload-number">1</span></span>
                <div class="level-indicator"><div class="level-filled" id="reload-level" style="width: 10%;"></div></div>
                <div class="upgrade-button" id="reload-btn">+</div>
            </div>
            <div class="upgrade-item">
                <span class="upgrade-name">Movement Speed <span class="level-number" id="movementSpeed-number">1</span></span>
                <div class="level-indicator"><div class="level-filled" id="movementSpeed-level" style="width: 10%;"></div></div>
                <div class="upgrade-button" id="movementSpeed-btn">+</div>
            </div>
            <div id="upgrade-status">Verf√ºgbare Punkte: 0 | Upgrades: 0/45</div>
        </div>

        <!-- Death Screen (Diep.io Style) -->
        <div id="death-screen">
            <div class="death-content">
                <h2 id="death-title">You were killed by</h2>
                <h1 id="death-killer">Unknown</h1>

                <div id="death-stats">
                    <div class="death-stat-row">
                        <span class="death-stat-label">Score:</span>
                        <span class="death-stat-value" id="death-score">0</span>
                    </div>
                    <div class="death-stat-row">
                        <span class="death-stat-label">Level:</span>
                        <span class="death-stat-value" id="death-level">1</span>
                    </div>
                    <div class="death-stat-row">
                        <span class="death-stat-label">Time:</span>
                        <span class="death-stat-value" id="death-time">0s</span>
                    </div>
                </div>

                <div class="death-coins-earned" id="death-coins-display" style="display: none;">
                    <span class="coin-icon">üí∞</span>
                    <span id="death-coins">0</span> Coins verdient
                </div>

                <div id="death-missions" style="display: none;">
                    <h3 style="margin-bottom: 10px;">T√§gliche Missionen</h3>
                    <div id="death-missions-list" style="max-height: 200px; overflow-y: auto;">
                        <!-- Wird dynamisch bef√ºllt -->
                    </div>
                </div>

                <div id="death-achievement">
                    <div id="death-achievement-title">Achievement Unlocked!</div>
                    <div id="death-achievement-text">Ran into something</div>
                </div>

                <button id="death-continue-btn">Continue</button>
            </div>
        </div>

        <!-- Admin Panel -->
        <div id="admin-panel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.85); padding: 20px; border-radius: 10px; z-index: 1000; color: white; width: 90%; max-width: 600px; height: 400px; box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);">
            <!-- Admin panel content -->
            <button id="admin-close-btn" style="background: #e74c3c; color: white; border: none; padding: 8px 20px; border-radius: 4px; cursor: pointer;">Schlie√üen</button>
        </div>

        <!-- IMPROVED Mobile Controls -->
        <div class="mobile-controls" id="mobile-controls">
            <!-- Left joystick for movement -->
            <div class="joystick-area" id="joystick-area">
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
            
            <!-- Right area for aiming/firing -->
            <div class="fire-area" id="fire-area">
                <div class="fire-lines"></div>
                <div class="fire-button" id="fire-button"></div>
            </div>
            
            <!-- Auto-fire toggle button -->
            <div class="auto-fire-btn" id="auto-fire-btn">AUTO</div>
        </div>

        <script src="/socket.io/socket.io.js"></script>
        <script>
            console.log("Spiel wird initialisiert...");

            // Namen aus URL lesen
            const urlParams = new URLSearchParams(window.location.search);
            const playerName = urlParams.get("name") || "Unbenannt";
            console.log("Spielername aus URL:", playerName);

            // Token und Upgrade aus URL holen, falls vorhanden
            let playerToken = null;
            let playerUpgrade = null;

            if (urlParams.has('token')) {
                playerToken = urlParams.get('token');
                console.log("Token aus URL gelesen:", playerToken);
            }
            if (urlParams.has('upgrade')) {
                playerUpgrade = urlParams.get('upgrade');
            }

            // Canvas einrichten
            const canvas = document.getElementById("game-canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Partikeleffekte Canvas
            const particleCanvas = document.getElementById("particle-canvas");
            const particleCtx = particleCanvas.getContext("2d");
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;

            // Partikelsystem f√ºr Kollisionseffekte
            const particles = [];

            function createExplosion(x, y, color = "#f39c12", count = 12) {
                const screenX = x - camera.x;
                const screenY = y - camera.y;

                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;
                    const size = 3 + Math.random() * 5;
                    const lifetime = 30 + Math.random() * 30;

                    particles.push({
                        x: screenX,
                        y: screenY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: size,
                        color: color,
                        lifetime: lifetime,
                        age: 0
                    });
                }
            }

            function updateParticles() {
                particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.age++;

                    if (p.age >= p.lifetime) {
                        particles.splice(i, 1);
                        continue;
                    }

                    p.x += p.vx;
                    p.y += p.vy;

                    const alpha = 1 - (p.age / p.lifetime);
                    particleCtx.globalAlpha = alpha;
                    particleCtx.fillStyle = p.color;
                    particleCtx.beginPath();
                    particleCtx.arc(p.x, p.y, p.size * (1 - p.age/p.lifetime), 0, Math.PI * 2);
                    particleCtx.fill();
                }

                particleCtx.globalAlpha = 1;
            }

            // Spielkonstanten
            const PLAYER_BASE_SIZE = 25;
            const BULLET_BASE_SIZE = 15;
            const GAME_WIDTH = 4000;
            const GAME_HEIGHT = 4000;

            // Game-Variablen
            let socket;
            let player = null;
            let players = {};
            let bullets = [];
            let blocks = [];
            let camera = { x: 0, y: 0 };
            
            // Camera/Zoom settings
            let cameraZoomFactor = 1; // Default zoom is 1 (no zoom)
            
            // Set zoom factor based on device type
            function setCameraZoom() {
                // Check if mobile
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 767;
                if (isMobile) {
                    // Zoom out more on mobile to see more of the game
                    cameraZoomFactor = 1.5; // Zoom out - higher number means more of the map is visible
                } else {
                    cameraZoomFactor = 1.1; // Slight zoom out on desktop
                }
                console.log("Camera zoom factor set to:", cameraZoomFactor);
            }
            
            // Set initial zoom
            setCameraZoom();

            // Death Screen Variablen
            let gameStartTime = Date.now();
            let killerViewActive = false;
            let killerViewData = null;

            // Admin-Status und Funktionen
            let isAdmin = false; 

            // Die ADMIN_CONFIG Objekt ohne Passwort
            const ADMIN_CONFIG = {
                GOD_MODE: false,
                SELECTED_PLAYER_ID: null
            };

            // Upgrade-Men√º-Elemente
            const upgradeMenu = document.getElementById("upgrade-menu");
            const upgradeStatus = document.getElementById("upgrade-status");

            // Upgrade-Buttons einrichten
            const upgradeSkills = [
                "healthRegen", "maxHealth", "bodyDamage", "bulletSpeed", 
                "bulletPenetration", "bulletDamage", "reload", "movementSpeed"
            ];

            upgradeSkills.forEach(skill => {
                const button = document.getElementById(`${skill}-btn`);
                if (button) {
                    button.addEventListener("click", () => {
                        if (player && player.availableUpgrades > 0 && 
                            player.upgrades[skill].level < player.upgrades[skill].max &&
                            player.totalUpgrades < player.maxTotalUpgrades) {
                            socket.emit("upgrade", skill);
                        }
                    });
                }
            });

            // Benachrichtigung erstellen
            function createNotification(message, duration = 3000) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                notification.style.position = 'absolute';
                notification.style.top = '50px';
                notification.style.left = '50%';
                notification.style.transform = 'translateX(-50%)';
                notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                notification.style.color = 'white';
                notification.style.padding = '8px 16px';
                notification.style.borderRadius = '4px';
                notification.style.zIndex = '1000';
                notification.style.transition = 'opacity 0.5s';
                notification.style.fontSize = window.innerWidth <= 767 ? '12px' : '14px';

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        notification.remove();
                    }, 500);
                }, duration);
            }

            // XP-Bar aktualisieren (Diep.io Style)
            function updateXPBar() {
                if (!player) return;

                const xpBar = document.getElementById("xp-bar");
                const xpText = document.getElementById("xp-text");

                const percentage = (player.xp / player.xpToNextLevel) * 100;
                xpBar.style.width = `${percentage}%`;

                xpText.textContent = `Level ${player.level} - ${Math.floor(player.xp)}/${player.xpToNextLevel} XP`;
            }

            // Leaderboard aktualisieren
            function updateLeaderboard(data) {
                const leaderboardItems = document.getElementById("leaderboard-items");
                leaderboardItems.innerHTML = "";

                data.forEach((item, index) => {
                    const div = document.createElement("div");
                    div.className = "leaderboard-item";

                    const isCurrentPlayer = item.id === socket.id;

                    div.innerHTML = `
                        <span>${index + 1}. ${item.isLeader ? '<span class="crown">üëë</span>' : ''}
                            <span class="leaderboard-name" style="${isCurrentPlayer ? 'color: #3498db;' : ''}">${item.name}</span>
                        </span>
                        <span>Lvl ${item.level}</span>
                    `;

                    leaderboardItems.appendChild(div);
                });

                // Wenn weniger als 5 Spieler, leere Pl√§tze anzeigen
                for (let i = data.length; i < 5; i++) {
                    const div = document.createElement("div");
                    div.className = "leaderboard-item";
                    div.innerHTML = `<span>${i + 1}. ---</span><span>---</span>`;
                    leaderboardItems.appendChild(div);
                }
                
                // Update player count
                document.getElementById("players-count").textContent = `Spieler: ${Object.keys(players).length}`;
            }

            // Upgrade-UI aktualisieren
            function updateUpgradeUI() {
                if (!player) return;

                // Upgrade-Men√º anzeigen, wenn Spieler Level-Punkte hat
                upgradeMenu.style.display = (player.availableUpgrades > 0) ? "block" : "none";

                // Status aktualisieren
                upgradeStatus.textContent = `Level-Punkte: ${player.availableUpgrades} | Upgrades: ${player.totalUpgrades}/${player.maxTotalUpgrades}`;

                // F√ºr jedes Upgrade den Level und Button-Status aktualisieren
                upgradeSkills.forEach(skill => {
                    const levelIndicator = document.getElementById(`${skill}-level`);
                    const levelNumber = document.getElementById(`${skill}-number`);
                    const button = document.getElementById(`${skill}-btn`);

                    if (levelIndicator && button && levelNumber) {
                        const upgrade = player.upgrades[skill];

                        // Level-Anzeige aktualisieren
                        const percentage = (upgrade.level / upgrade.max) * 100;
                        levelIndicator.style.width = `${percentage}%`;

                        // Level-Nummer aktualisieren
                        levelNumber.textContent = upgrade.level;

                        // Farbe der Level-Nummer basierend auf Level anpassen
                        if (upgrade.level <= 3) {
                            levelNumber.style.backgroundColor = "#3498db"; // Blau
                        } else if (upgrade.level <= 6) {
                            levelNumber.style.backgroundColor = "#2ecc71"; // Gr√ºn
                        } else if (upgrade.level <= 9) {
                            levelNumber.style.backgroundColor = "#f39c12"; // Orange
                        } else {
                            levelNumber.style.backgroundColor = "#e74c3c"; // Rot
                        }

                        // Button-Status
                        const canUpgrade = 
                            player.availableUpgrades > 0 && 
                            upgrade.level < upgrade.max && 
                            player.totalUpgrades < player.maxTotalUpgrades;

                        button.classList.toggle("disabled", !canUpgrade);

                        // Anzeige als Tooltip
                        button.title = canUpgrade ? 
                            `Auf Level ${upgrade.level + 1} verbessern (${upgrade.level}/${upgrade.max})` : 
                            `Maximum: ${upgrade.max} (aktuell: ${upgrade.level})`;
                    }
                });
            }

            // Debug-Modus mit Strg+Alt+D umschalten
            let debugMode = false;
            window.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.altKey && e.key === 'd') {
                    debugMode = !debugMode;
                    document.getElementById('debug-info').style.display = debugMode ? 'block' : 'none';
                }
            });

            // Debug-Funktion
            function debugLog(message) {
                if (debugMode) {
                    console.log(message);
                    const debugInfo = document.getElementById('debug-info');
                    debugInfo.innerHTML += message + '<br>';
                    if (debugInfo.innerHTML.length > 1000) {
                        debugInfo.innerHTML = debugInfo.innerHTML.substring(debugInfo.innerHTML.length - 1000);
                    }
                }
            }

            // Canvas Gr√∂√üen√§nderung behandeln
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                particleCanvas.width = window.innerWidth;
                particleCanvas.height = window.innerHeight;
                
                // Readjust camera zoom on resize
                setCameraZoom();
            });

            // Death Screen Funktionen
            function initTimeTracking() {
                gameStartTime = Date.now();
            }

            function formatGameTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
            }

            // Missionen f√ºr den DeathScreen laden
            function loadMissionsForDeathScreen() {
                if (!playerToken) return;

                console.log("Lade Missionen f√ºr DeathScreen mit Token:", playerToken);

                fetch(`https://nm-web.de/get_daily_missions.php?token=${encodeURIComponent(playerToken)}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log("Erhaltene Missionsdaten:", data);
                        if (data.success && data.missions && data.missions.length > 0) {
                            // Missionsbereich einblenden
                            document.getElementById('death-missions').style.display = 'block';

                            // Missionen anzeigen
                            displayMissionsInDeathScreen(data.missions);
                        } else {
                            console.log("Keine Missionen erhalten oder Fehler in der Antwort");
                            document.getElementById('death-missions').style.display = 'none';
                        }
                    })
                    .catch(error => {
                        console.error('Fehler beim Laden der Missionen f√ºr den DeathScreen:', error);
                        document.getElementById('death-missions').style.display = 'none';
                    });
            }

            // Missionen im DeathScreen anzeigen
            function displayMissionsInDeathScreen(missions) {
                const missionsList = document.getElementById('death-missions-list');
                missionsList.innerHTML = '';

                console.log("Zeige diese Missionen an:", missions);

                missions.forEach(mission => {
                    const progress = mission.progress || 0;
                    const target = mission.target || 1;
                    const percentage = Math.min(100, Math.round((progress / target) * 100));
                    const isComplete = percentage >= 100;

                    const missionElement = document.createElement('div');
                    missionElement.className = `death-mission-item ${isComplete ? 'death-mission-complete' : ''}`;
                    missionElement.innerHTML = `
                        <div style="display: flex; justify-content: space-between;">
                            <div>${mission.description}</div>
                            <div class="death-mission-reward">+${mission.reward}</div>
                        </div>
                        <div class="death-mission-progress">
                            <div class="death-mission-bar">
                                <div class="death-mission-fill" style="width: ${percentage}%;"></div>
                            </div>
                            <div class="death-mission-status">
                                ${progress}/${target} ${isComplete && !mission.claimed ? '‚úì' : ''}
                            </div>
                        </div>
                    `;

                    missionsList.appendChild(missionElement);
                });
            }

            function showDeathScreen(data) {
                console.log("Death Screen mit Daten anzeigen:", data);

                const deathScreen = document.getElementById('death-screen');
                const deathKiller = document.getElementById('death-killer');
                const deathScore = document.getElementById('death-score');
                const deathLevel = document.getElementById('death-level');
                const deathTime = document.getElementById('death-time');
                const deathCoinsDisplay = document.getElementById('death-coins-display');
                const deathCoins = document.getElementById('death-coins');
                const deathContinueBtn = document.getElementById('death-continue-btn');

                // Set death screen data
                deathKiller.textContent = data.killerName || "Unknown";
                deathScore.textContent = data.score || 0;
                deathLevel.textContent = data.level || 1;

                // Coins anzeigen, falls verf√ºgbar
                if (data.coins_earned) {
                    deathCoins.textContent = data.coins_earned;
                    deathCoinsDisplay.style.display = 'flex';
                    console.log("Zeige verdiente Coins an:", data.coins_earned);
                } else {
                    deathCoinsDisplay.style.display = 'none';
                }

                // Calculate game time
                const gameTime = Date.now() - gameStartTime;
                deathTime.textContent = formatGameTime(gameTime);

                // Show achievement if applicable
                const achievementDiv = document.getElementById('death-achievement');
                const achievementText = document.getElementById('death-achievement-text');

                if (data.achievement) {
                    achievementDiv.style.display = 'block';
                    achievementText.textContent = data.achievement;
                } else {
                    achievementDiv.style.display = 'none';
                }

                // Update UI for death screen
                deathScreen.style.display = 'block';

                // Hide gameplay UI elements
                document.getElementById('minimap-container').style.display = 'none';
                document.getElementById('leaderboard').style.display = 'none';
                document.getElementById('xp-bar-container').style.display = 'none';
                document.getElementById('upgrade-menu').style.display = 'none';

                // Hide mobile controls
                document.body.classList.add('controls-hidden');

                // Missionen laden, falls angemeldet
                if (playerToken) {
                    console.log("Lade Missionen f√ºr angemeldeten Spieler mit Token:", playerToken);
                    loadMissionsForDeathScreen();
                } else {
                    console.log("Kein playerToken, zeige keine Missionen an");
                    document.getElementById('death-missions').style.display = 'none';
                }

                // Set up continue button
                deathContinueBtn.addEventListener('click', function() {
                    location.reload();
                });

                // If killer exists, show their view
                if (data.killerId && players[data.killerId]) {
                    killerViewActive = true;
                    killerViewData = players[data.killerId];
                }
            }

            function updateKillerView() {
                if (!killerViewActive || !killerViewData) return;

                // Update camera to follow killer
                camera.x = killerViewData.x - canvas.width / 2;
                camera.y = killerViewData.y - canvas.height / 2;
            }

            // Missionsverfolgung implementieren
            function trackMissionProgress(type, amount) {
                if (!playerToken) return; // Nur f√ºr angemeldete Spieler

                console.log(`Sende Mission-Fortschritt: ${type}, Menge: ${amount}, Token: ${playerToken}`);

                // Fetch verwenden, um Fortschritt zu senden
                fetch(`https://nm-web.de/update_mission_progress.php?token=${encodeURIComponent(playerToken)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        type: type,
                        amount: amount
                    })
                })
                .then(response => response.json())
                .then(data => {
                    // Auf abgeschlossene Missionen reagieren
                    if (data.completed_missions && data.completed_missions.length > 0) {
                        data.completed_missions.forEach(mission => {
                            createNotification(`Mission abgeschlossen: ${mission.description}! +${mission.reward} Coins`, 5000);

                            // Visueller Effekt f√ºr abgeschlossene Mission
                            if (player) {
                                createExplosion(player.x, player.y, "#f1c40f", 20); // Goldener Explosionseffekt
                            }
                        });
                    }
                })
                .catch(error => console.error('Fehler beim Aktualisieren des Missionsfortschritts:', error));
            }

            // Funktion zur Admin-Status-Pr√ºfung
            function checkAdminStatus(token, callback) {
                fetch('https://nm-web.de/check_admin_status.php?token=' + encodeURIComponent(token))
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            isAdmin = data.is_admin;
                            callback(isAdmin);
                        } else {
                            isAdmin = false;
                            callback(false);
                        }
                    })
                    .catch(error => {
                        console.error('Admin-Status-Pr√ºfung fehlgeschlagen:', error);
                        isAdmin = false;
                        callback(false);
                    });
            }

            // Spiel direkt starten
            startGame();

            function startGame() {
                console.log("Starte Spiel mit Namen:", playerName);

                // Socket.io initialisieren
                socket = io();

                // Event-Handler
                socket.on("connect", () => {
                    console.log("Verbunden mit Server, Socket-ID:", socket.id);
                    // Join-Daten mit Token und Upgrade
                    socket.emit("join", {
                        name: playerName,
                        token: playerToken,
                        upgrade: playerUpgrade
                    });
                });

                socket.on("init", (data) => {
                    console.log("Spiel initialisiert:", data);
                    player = data.player;
                    players = data.players;
                    blocks = data.blocks;
                    document.getElementById("loading").style.display = "none";

                    // NEU: Wenn God-Mode schon aktiviert war, sofort an Server senden
                    if (ADMIN_CONFIG && ADMIN_CONFIG.GOD_MODE === true) {
                        console.log("God-Mode beim Start aktiviert, sende an Server");
                        socket.emit('admin_toggle_god_mode', {
                            token: playerToken,
                            enabled: true
                        });
                    }

                    // UI initialisieren
                    updateUpgradeUI();
                    updateXPBar();

                    // NEU: Spielzeit Tracking starten
                    initTimeTracking();
                });

                socket.on("gameState", (data) => {
                    players = data.players;
                    bullets = data.bullets;
                    blocks = data.blocks;

                    if (socket.id in players) {
                        player = players[socket.id];
                        updateUpgradeUI();
                        updateXPBar();
                    }
                });

                socket.on('leaderboardUpdate', (leaderboardData) => {
                    updateLeaderboard(leaderboardData);
                });

                socket.on('levelUp', (data) => {
                    createNotification(`Level Up! Sie sind jetzt Level ${data.level}!`);
                    // Animation f√ºr Level-Up hinzuf√ºgen
                    createExplosion(player.x, player.y, "#2ecc71", 30);

                    // Sound-Effekt k√∂nnte hier eingef√ºgt werden
                    if (player) {
                        player.level = data.level;
                        player.xpToNextLevel = data.xpToNextLevel;
                        player.availableUpgrades = data.availableUpgrades;

                        // Sofort UI aktualisieren
                        updateXPBar();
                        updateUpgradeUI();
                    }

                    // Mission tracken
                    if (playerToken) {
                        trackMissionProgress('reach_level', data.level);
                    }
                });

                socket.on('xpGained', (data) => {
                    if (data.fromKill) {
                        createNotification(`+${data.amount} XP von der Beseitigung von ${data.victimName}!`);
                    }
                    updateXPBar();

                    // Mission tracken
                    if (playerToken) {
                        trackMissionProgress('collect_xp', data.amount);
                    }
                });

                socket.on('playerDamaged', (data) => {
                    if (data.id in players) {
                        players[data.id].health = data.health;
                        debugLog(`Spieler ${players[data.id].name} hat Schaden erhalten: ${data.health}`);
                    }
                });

                socket.on('blockDamaged', (data) => {
                    const block = blocks.find(b => b.id === data.id);
                    if (block) {
                        block.health = data.health;
                        debugLog(`Block ${data.id} hat Schaden erhalten: ${data.health}`);
                    }

                    // Block zerst√∂rt, tracke Mission
                    if (block && data.health <= 0 && playerToken) {
                        trackMissionProgress('destroy_blocks', 1);
                    }
                });

                socket.on('bulletCollision', (data) => {
                    // Kollisionseffekt hinzuf√ºgen
                    createExplosion(data.x, data.y, "#f39c12", 15);
                    debugLog(`Kugelkollision bei ${data.x}, ${data.y}`);
                });

                socket.on('upgradeApplied', (data) => {
                    if (player) {
                        player.upgrades[data.skill].level = data.level;
                        player.totalUpgrades = data.totalUpgrades;
                        player.availableUpgrades = data.availableUpgrades;

                        updateUpgradeUI();
                        debugLog(`Upgrade ${data.skill} auf Level ${data.level} erh√∂ht`);
                    }
                });

                // God-Mode-Ende behandeln
                socket.on('godModeEnded', () => {
                    // Visuelle R√ºckmeldung f√ºr den Spieler
                    createNotification('Unsterblichkeit ist abgelaufen!');
                });

                // NEU: Verbesserter 'died' Event-Handler
                socket.on('died', (data) => {
                    debugLog('Du bist gestorben!');
                    console.log('Tod-Event erhalten mit Daten:', data);

                    // Wenn angemeldet, sende Statistiken an den Server und hole Coins-Info
                    if (playerToken) {
                        const gameTime = (Date.now() - gameStartTime) / 1000; // in Sekunden
                        console.log("Sende Spielstatistiken mit Token:", playerToken);

                        fetch(`https://nm-web.de/game_end.php`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                token: playerToken,
                                playtime: gameTime,
                                kills: player ? (player.kills || 0) : 0,
                                max_level: player ? (player.level || 1) : 1,
                                score: data.score || 0
                            })
                        })
                        .then(response => response.json())
                        .then(gameEndData => {
                            console.log("Game-End Daten erhalten:", gameEndData);

                            // Coins zum Death-Screen-Data hinzuf√ºgen
                            data.coins_earned = gameEndData.coins_earned || 0;

                            // Death Screen mit den aktualisierten Daten anzeigen
                            showDeathScreen(data);
                        })
                        .catch(error => {
                            console.error('Fehler beim Senden der Spielstatistiken:', error);

                            // Trotzdem Death Screen anzeigen, aber ohne Coins-Info
                            showDeathScreen(data);
                        });
                    } else {
                        // Direkt Death Screen anzeigen, wenn nicht angemeldet
                        showDeathScreen(data);
                    }
                });

                // Tracking f√ºr Kills hinzuf√ºgen
                socket.on('playerLeft', (playerId) => {
                    // Wenn ein Spieler das Spiel verl√§sst
                    if (document.getElementById('admin-panel').style.display === 'block') {
                        // Wenn der selektierte Spieler das Spiel verlassen hat, Auswahl zur√ºcksetzen
                        if (ADMIN_CONFIG.SELECTED_PLAYER_ID === playerId) {
                            ADMIN_CONFIG.SELECTED_PLAYER_ID = null;
                        }
                    }

                    // Einfache Heuristik: Wenn ein Spieler verschwindet und unsere Kugeln in der N√§he waren, z√§hlt es als Kill
                    if (playerToken && bullets.some(b => b.ownerId === socket.id)) {
                        // Schauen, ob einer der Spieler, die das Spiel verlassen haben, in der N√§he unserer Kugeln war
                        const exitedPlayer = players[playerId];
                        if (exitedPlayer && bullets.some(b => 
                            b.ownerId === socket.id && 
                            Math.hypot(b.x - exitedPlayer.x, b.y - exitedPlayer.y) < 100)) {
                            // Es ist wahrscheinlich, dass wir diesen Spieler get√∂tet haben
                            trackMissionProgress('kill_enemies', 1);
                        }
                    }
                });

                // Spielsteuerung einrichten
                setupControls();

                // Mobile Steuerung einrichten
                setupMobileControls();

                // Spielschleife starten
                requestAnimationFrame(gameLoop);

                // Regelm√§√üiges Update f√ºr die Spielzeit
                setInterval(() => {
                    if (playerToken && player) {
                        trackMissionProgress('play_minutes', 1);
                        trackMissionProgress('survive_minutes', 1);
                    }
                }, 60000); // Jede Minute
            }

            // Steuerung einrichten
            function setupControls() {
                const keys = { w: false, a: false, s: false, d: false };
                let isMouseDown = false;
                let shootingInterval = null;
                const shootingSpeed = 33; // Ca. 30 Sch√ºsse pro Sekunde, passend zum Game-Loop

                window.addEventListener("keydown", (e) => {
                    if (e.key.toLowerCase() in keys) {
                        keys[e.key.toLowerCase()] = true;
                    }
                });

                window.addEventListener("keyup", (e) => {
                    if (e.key.toLowerCase() in keys) {
                        keys[e.key.toLowerCase()] = false;
                    }
                });

                window.addEventListener("mousemove", (e) => {
                    if (player && socket) {
                        const dx = e.clientX - canvas.width / 2;
                        const dy = e.clientY - canvas.height / 2;
                        const angle = Math.atan2(dy, dx);
                        socket.emit("rotate", angle);
                    }
                });

                // Kontinuierliches Schie√üen mit gedr√ºckter Maustaste
                window.addEventListener("mousedown", (e) => {
                    if (e.button === 0 && socket) {
                        // Linke Maustaste
                        isMouseDown = true;

                        // Ersten Schuss sofort abfeuern
                        socket.emit("shoot");

                        // Kontinuierliches Schie√üen starten
                        shootingInterval = setInterval(() => {
                            if (isMouseDown && player && socket) {
                                socket.emit("shoot");
                            }
                        }, shootingSpeed);
                    }
                });

                // Schie√üen stoppen, wenn Maustaste losgelassen wird
                window.addEventListener("mouseup", (e) => {
                    if (e.button === 0) {
                        isMouseDown = false;

                        // Schie√üen stoppen
                        if (shootingInterval) {
                            clearInterval(shootingInterval);
                            shootingInterval = null;
                        }
                    }
                });

                // Auch das Interval leeren wenn die Maus das Fenster verl√§sst
                window.addEventListener("mouseout", (e) => {
                    if (e.relatedTarget == null) { // Maus hat das Fenster verlassen
                        isMouseDown = false;

                        if (shootingInterval) {
                            clearInterval(shootingInterval);
                            shootingInterval = null;
                        }
                    }
                });

                // Bewegung
                setInterval(() => {
                    if (player && socket) {
                        let dx = 0,
                            dy = 0;

                        if (keys.w) dy -= 1;
                        if (keys.s) dy += 1;
                        if (keys.a) dx -= 1;
                        if (keys.d) dx += 1;

                        // Diagonale Bewegung normalisieren
                        if (dx !== 0 && dy !== 0) {
                            dx *= 0.7071;
                            dy *= 0.7071;
                        }

                        // Nur senden, wenn Bewegung vorhanden ist
                        if (dx !== 0 || dy !== 0) {
                            socket.emit("move", { dx, dy });
                        }
                    }
                }, 33);
            }

            // Event-Listener f√ºr Admin-Men√º
            window.addEventListener('keydown', (e) => {
                if (e.key === 'u') {
                    // Nur das Admin-Dialog anzeigen, wenn der Benutzer angemeldet ist
                    if (playerToken) {
                        // Admin-Status vom Server pr√ºfen
                        checkAdminStatus(playerToken, (isUserAdmin) => {
                            if (isUserAdmin) {
                                document.getElementById('admin-panel').style.display = 'block';
                            } else {
                                createNotification('Kein Admin-Zugriff', 3000);
                            }
                        });
                    } else {
                        createNotification('Du musst angemeldet sein f√ºr Admin-Zugriff', 3000);
                    }
                }
            });

            // Admin Panel schlie√üen
            document.getElementById('admin-close-btn').addEventListener('click', () => {
                document.getElementById('admin-panel').style.display = 'none';
            });

            // IMPROVED: Spielschleife mit Unterst√ºtzung f√ºr Killer-View
            function gameLoop() {
                if (player || killerViewActive) {
                    // Spielzustand aktualisieren
                    if (player) {
                        update();
                    } else if (killerViewActive) {
                        updateKillerView();
                    }

                    // Alles zeichnen
                    drawGame();

                    // Partikel aktualisieren
                    updateParticles();
                }

                requestAnimationFrame(gameLoop);
            }

            // Spielzustand aktualisieren
            function update() {
                // IMPROVED: Kamera auf Spieler zentrieren mit Zoom
                camera.x = player.x - (canvas.width / 2 / cameraZoomFactor);
                camera.y = player.y - (canvas.height / 2 / cameraZoomFactor);

                // Kollisionen pr√ºfen
                checkPlayerCollisions();
            }

            // Kollisionen des Spielers pr√ºfen
            function checkPlayerCollisions() {
                if (!player) return;

                // Bei aktiviertem God-Mode keine Kollisionspr√ºfung durchf√ºhren
                if (ADMIN_CONFIG && ADMIN_CONFIG.GOD_MODE === true) {
                    return;
                }

                // Kollision mit Bl√∂cken pr√ºfen
                for (const block of blocks) {
                    const dx = player.x - block.x;
                    const dy = player.y - block.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = 30 + (block.size || 30) / 2; // Spielergr√∂√üe + Blockgr√∂√üe/2

                    if (distance < minDistance) {
                        // Kollision! Schaden verursachen
                        const damage = player.upgrades.bodyDamage.level; // Schaden basierend auf K√∂rperschaden
                        socket.emit("takeDamage", {
                            damage,
                            type: "block",
                            id: block.id,
                        });
                        debugLog(`Kollision mit Block ${block.id}, Schaden: ${damage}`);

                        // Wegdr√ºcken (einfache Physik)
                        const angle = Math.atan2(dy, dx);
                        const pushX = Math.cos(angle) * (minDistance - distance);
                        const pushY = Math.sin(angle) * (minDistance - distance);
                        socket.emit("move", {
                            dx: pushX * 0.1,
                            dy: pushY * 0.1,
                        });
                    }
                }

                // Kollision mit anderen Spielern pr√ºfen
                for (const id in players) {
                    if (id === socket.id) continue; // Nicht mit sich selbst kollidieren

                    const otherPlayer = players[id];
                    const dx = player.x - otherPlayer.x;
                    const dy = player.y - otherPlayer.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = 30 + 30; // Beide Spieler haben Radius 30

                    if (distance < minDistance) {
                        // Kollision! Schaden verursachen
                        const damage = player.upgrades.bodyDamage.level * 2; // Spieler-gegen-Spieler-Schaden
                        socket.emit("takeDamage", {
                            damage,
                            type: "player",
                            id: id,
                        });
                        debugLog(`Kollision mit Spieler ${otherPlayer.name}, Schaden: ${damage}`);

                        // Wegdr√ºcken
                        const angle = Math.atan2(dy, dx);
                        const pushX = Math.cos(angle) * (minDistance - distance);
                        const pushY = Math.sin(angle) * (minDistance - distance);
                        socket.emit("move", {
                            dx: pushX * 0.1,
                            dy: pushY * 0.1,
                        });
                    }
                }
            }

            // VERBESSERTE Spiel zeichnen Funktion
            function drawGame() {
                // Hintergrund
                ctx.fillStyle = "#f0f0f0";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Dunklere Bereiche au√üerhalb der Map zeichnen
                const mapBorderWidth = 100; // Breite des dunkleren Bereichs am Rand
                const borderColor = "rgba(0, 0, 0, 0.3)"; // Halbtransparentes Schwarz

                // Spielfeldgrenzen berechnen (basierend auf Kameraposition)
                const leftEdge = 0 - camera.x;
                const rightEdge = GAME_WIDTH - camera.x;
                const topEdge = 0 - camera.y;
                const bottomEdge = GAME_HEIGHT - camera.y;

                // Bereiche au√üerhalb zeichnen (links, rechts, oben, unten)
                ctx.fillStyle = borderColor;

                // Links
                if (leftEdge > 0) {
                    ctx.fillRect(0, 0, leftEdge, canvas.height);
                }

                // Rechts
                if (rightEdge < canvas.width) {
                    ctx.fillRect(rightEdge, 0, canvas.width - rightEdge, canvas.height);
                }

                // Oben
                if (topEdge > 0) {
                    ctx.fillRect(0, 0, canvas.width, topEdge);
                }

                // Unten
                if (bottomEdge < canvas.height) {
                    ctx.fillRect(0, bottomEdge, canvas.width, canvas.height - bottomEdge);
                }

                // SPIELFELDRAND VISUELL MARKIEREN
                if (leftEdge < mapBorderWidth && leftEdge > 0) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
                    ctx.fillRect(leftEdge - mapBorderWidth, 0, mapBorderWidth, canvas.height);
                }

                if (rightEdge > canvas.width - mapBorderWidth && rightEdge < canvas.width) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
                    ctx.fillRect(rightEdge, 0, mapBorderWidth, canvas.height);
                }

                if (topEdge < mapBorderWidth && topEdge > 0) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
                    ctx.fillRect(0, topEdge - mapBorderWidth, canvas.width, mapBorderWidth);
                }

                if (bottomEdge > canvas.height - mapBorderWidth && bottomEdge < canvas.height) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
                    ctx.fillRect(0, bottomEdge, canvas.width, mapBorderWidth);
                }

                // Raster zeichnen (nur innerhalb des Spielfelds)
                drawGrid();

                // Bl√∂cke zeichnen
                blocks.forEach((block) => {
                    drawBlock(block);
                });

                // Geschosse zeichnen
                bullets.forEach((bullet) => {
                    drawBullet(bullet);
                });

                // Andere Spieler zeichnen
                for (const id in players) {
                    if (id !== socket.id || !player) {
                        drawPlayer(players[id], id === socket.id);
                    }
                }

                // Eigenen Spieler zeichnen (nur wenn aktiv, nicht im Death Screen)
                if (player) {
                    drawPlayer(player, true);
                }

                // UI zeichnen
                if (player) {
                    drawUI();
                }

                // Minimap zeichnen
                if (!killerViewActive) {
                    drawMinimap();
                }
            }

            // VERBESSERTES Raster zeichnen
            function drawGrid() {
                const gridSize = 30;
                const offsetX = -camera.x % gridSize;
                const offsetY = -camera.y % gridSize;

                // Spielfeldgrenzen
                const leftEdge = Math.max(0, 0 - camera.x);
                const rightEdge = Math.min(canvas.width, GAME_WIDTH - camera.x);
                const topEdge = Math.max(0, 0 - camera.y);
                const bottomEdge = Math.min(canvas.height, GAME_HEIGHT - camera.y);

                ctx.strokeStyle = "#ddd";
                ctx.lineWidth = 1;

                // Vertikale Linien (nur innerhalb der Spielfeldgrenzen)
                for (let x = offsetX + leftEdge; x < rightEdge; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, topEdge);
                    ctx.lineTo(x, bottomEdge);
                    ctx.stroke();
                }

                // Horizontale Linien (nur innerhalb der Spielfeldgrenzen)
                for (let y = offsetY + topEdge; y < bottomEdge; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(leftEdge, y);
                    ctx.lineTo(rightEdge, y);
                    ctx.stroke();
                }
            }

            // Hilfsfunktionen zum Zeichnen
            function drawPlayer(player, isMainPlayer) {
                const screenX = player.x - camera.x;
                const screenY = player.y - camera.y;
                const size = PLAYER_BASE_SIZE; // Kleiner die Spielerkreise

                // Spieler-K√∂rper
                ctx.fillStyle = isMainPlayer ? "#3498db" : "#e74c3c";
                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fill();

                // Kanone
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(player.angle || 0);
                ctx.fillStyle = isMainPlayer ? "#2980b9" : "#c0392b";
                ctx.fillRect(0, -size / 4, size * 1.5, size / 2);
                ctx.restore();

                // Krone f√ºr den F√ºhrenden
                if (player.isLeader) {
                    ctx.save();
                    ctx.translate(screenX, screenY - size - 10);

                    // Krone zeichnen
                    ctx.fillStyle = "#f1c40f"; // Gold
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-5, -8);
                    ctx.lineTo(0, -3);
                    ctx.lineTo(5, -8);
                    ctx.lineTo(10, 0);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }

                // Gesundheitsleiste
                const healthBarWidth = size * 2;
                const healthBarHeight = 5; // Etwas kleiner
                const maxHealth = player.maxHealth || 100;
                const healthPercent = player.health / maxHealth;

                // Hintergrund der Gesundheitsleiste
                ctx.fillStyle = "#333";
                ctx.fillRect(
                    screenX - healthBarWidth / 2,
                    screenY + size + 8, // Etwas n√§her am Spieler
                    healthBarWidth,
                    healthBarHeight,
                );

                // Farbige Gesundheitsleiste
                if (healthPercent > 0.6) {
                    ctx.fillStyle = "#2ecc71"; // Gr√ºn
                } else if (healthPercent > 0.3) {
                    ctx.fillStyle = "#f39c12"; // Orange
                } else {
                    ctx.fillStyle = "#e74c3c"; // Rot
                }
                ctx.fillRect(
                    screenX - healthBarWidth / 2,
                    screenY + size + 8,
                    healthBarWidth * healthPercent,
                    healthBarHeight,
                );

                // Kleinere Name/Level Anzeige
                ctx.fillStyle = "#333";
                ctx.font = "12px Arial";
                ctx.textAlign = "center";
                ctx.fillText(player.name, screenX, screenY + size + 22);

                // Level
                if (player.level) {
                    ctx.font = "11px Arial";
                    ctx.fillText("Lvl " + player.level, screenX, screenY + size + 35);
                }
            }

            function drawBullet(bullet) {
                const screenX = bullet.x - camera.x;
                const screenY = bullet.y - camera.y;
                const size = bullet.size || 10;

                ctx.fillStyle =
                    bullet.ownerId === socket.id ? "#3498db" : "#e74c3c";
                ctx.beginPath();
                ctx.arc(screenX, screenY, size/2, 0, Math.PI * 2);
                ctx.fill();
            }

            function drawBlock(block) {
                const screenX = block.x - camera.x;
                const screenY = block.y - camera.y;
                const size = block.size || 30;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(block.rotation || 0);

                // Block entsprechend seiner Form zeichnen
                ctx.fillStyle = block.color || "#f1c40f";

                if (block.shape === 'triangle') {
                    // Dreieck zeichnen
                    ctx.beginPath();
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(-size/2, size/2);
                    ctx.lineTo(size/2, size/2);
                    ctx.closePath();
                    ctx.fill();
                } else if (block.shape === 'pentagon') {
                    // Pentagon zeichnen
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI / 5) - Math.PI/2;
                        const x = Math.cos(angle) * size/2;
                        const y = Math.sin(angle) * size/2;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Standard: Quadrat zeichnen
                    ctx.fillRect(-size/2, -size/2, size, size);
                }

                ctx.restore();

                // Gesundheitsleiste, falls gesetzt
                if (
                    block.health !== undefined &&
                    block.maxHealth !== undefined
                ) {
                    const healthBarWidth = size;
                    const healthBarHeight = 3; // Kleiner f√ºr mobile
                    const healthPercent = block.health / block.maxHealth;

                    // Hintergrund der Gesundheitsleiste
                    ctx.fillStyle = "#333";
                    ctx.fillRect(
                        screenX - healthBarWidth / 2,
                        screenY + size / 2 + 5,
                        healthBarWidth,
                        healthBarHeight,
                    );

                    // Farbige Gesundheitsleiste
                    ctx.fillStyle = healthPercent > 0.5 ? "#2ecc71" : "#e74c3c";
                    ctx.fillRect(
                        screenX - healthBarWidth / 2,
                        screenY + size / 2 + 5,
                        healthBarWidth * healthPercent,
                        healthBarHeight,
                    );
                }
            }

            function drawUI() {
                // Punktzahl anzeigen
                if (player) {
                    ctx.fillStyle = "#333";
                    ctx.font = "bold 14px Arial";
                    ctx.textAlign = "start";
                    ctx.fillText(`Score: ${player.score || 0}`, 20, 25);
                }
            }

            function drawMinimap() {
                // Im Death Screen keine Minimap zeichnen
                if (killerViewActive) return;

                const minimapCanvas = document.getElementById("minimap-canvas");
                const minimapCtx = minimapCanvas.getContext("2d");
                const minimapWidth = minimapCanvas.width;
                const minimapHeight = minimapCanvas.height;
                const mapWidth = GAME_WIDTH;
                const mapHeight = GAME_HEIGHT;

                // Minimap l√∂schen
                minimapCtx.fillStyle = "#f5f5f5";
                minimapCtx.fillRect(0, 0, minimapWidth, minimapHeight);

                // Raster auf Minimap zeichnen
                minimapCtx.strokeStyle = "#ddd";
                minimapCtx.lineWidth = 0.5;
                const gridSize = 10;
                for (let x = 0; x < minimapWidth; x += gridSize) {
                    minimapCtx.beginPath();
                    minimapCtx.moveTo(x, 0);
                    minimapCtx.lineTo(x, minimapHeight);
                    minimapCtx.stroke();
                }
                for (let y = 0; y < minimapHeight; y += gridSize) {
                    minimapCtx.beginPath();
                    minimapCtx.moveTo(0, y);
                    minimapCtx.lineTo(minimapWidth, y);
                    minimapCtx.stroke();
                }

                // R√§nder der Karte
                minimapCtx.strokeStyle = "#333";
                minimapCtx.lineWidth = 1;
                minimapCtx.strokeRect(0, 0, minimapWidth, minimapHeight);

                // Sichtfeld des Spielers mit Zoom-Ber√ºcksichtigung
                if (player) {
                    const viewX = (player.x / mapWidth) * minimapWidth;
                    const viewY = (player.y / mapHeight) * minimapHeight;
                    const viewW = (canvas.width / mapWidth / cameraZoomFactor) * minimapWidth;
                    const viewH = (canvas.height / mapHeight / cameraZoomFactor) * minimapHeight;

                    minimapCtx.strokeStyle = "#333";
                    minimapCtx.strokeRect(
                        viewX - viewW / 2,
                        viewY - viewH / 2,
                        viewW,
                        viewH,
                    );
                }

                // Bl√∂cke zeichnen
                if (blocks) {
                    blocks.forEach((block) => {
                        const blockX = (block.x / mapWidth) * minimapWidth;
                        const blockY = (block.y / mapHeight) * minimapHeight;

                        // Verschiedene Farben f√ºr verschiedene Blocktypen
                        minimapCtx.fillStyle = block.color || "#f1c40f";

                        if (block.shape === 'triangle') {
                            minimapCtx.beginPath();
                            minimapCtx.moveTo(blockX, blockY - 1);
                            minimapCtx.lineTo(blockX - 1, blockY + 1);
                            minimapCtx.lineTo(blockX + 1, blockY + 1);
                            minimapCtx.closePath();
                            minimapCtx.fill();
                        } else if (block.shape === 'pentagon') {
                            minimapCtx.beginPath();
                            minimapCtx.arc(blockX, blockY, 2, 0, Math.PI * 2);
                            minimapCtx.fill();
                        } else {
                            minimapCtx.fillRect(blockX - 1, blockY - 1, 2, 2);
                        }
                    });
                }

                // Spieler zeichnen (alle Spieler anzeigen)
                for (const id in players) {
                    const p = players[id];
                    const playerX = (p.x / mapWidth) * minimapWidth;
                    const playerY = (p.y / mapHeight) * minimapHeight;
                    
                    // Eigener Spieler blau, andere rot
                    minimapCtx.fillStyle = id === socket.id ? "#3498db" : "#e74c3c";
                    minimapCtx.beginPath();
                    minimapCtx.arc(playerX, playerY, id === socket.id ? 3 : 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                    
                    // Blickrichtung des eigenen Spielers anzeigen
                    if (id === socket.id) {
                        minimapCtx.strokeStyle = "#3498db";
                        minimapCtx.beginPath();
                        minimapCtx.moveTo(playerX, playerY);
                        minimapCtx.lineTo(
                            playerX + Math.cos(p.angle) * 6,
                            playerY + Math.sin(p.angle) * 6
                        );
                        minimapCtx.stroke();
                    }
                }
            }

            // IMPROVED MOBILE CONTROLS
            function setupMobileControls() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 767;
                const mobileControls = document.getElementById('mobile-controls');
                
                if (!isMobile) {
                    mobileControls.style.display = 'none';
                    return; // Wenn kein Mobilger√§t, nichts weiter tun
                }
                
                console.log("Mobilger√§t erkannt, aktiviere Touch-Steuerung");
                mobileControls.style.display = 'block';
                
                // Control elements
                const joystickArea = document.getElementById('joystick-area');
                const joystickThumb = document.getElementById('joystick-thumb');
                const fireArea = document.getElementById('fire-area');
                const fireButton = document.getElementById('fire-button');
                const autoFireBtn = document.getElementById('auto-fire-btn');
                
                // Control variables
                let joystickActive = false;
                let joystickStartPos = { x: 0, y: 0 };
                let joystickCurrentPos = { x: 0, y: 0 };
                let moveVector = { dx: 0, dy: 0 };
                
                let firingActive = false;
                let fireStartPos = { x: 0, y: 0 };
                let aimAngle = 0;
                let shootingInterval = null;
                let autoFireActive = false;
                
                // Auto-fire toggle
                autoFireBtn.addEventListener('click', function() {
                    autoFireActive = !autoFireActive;
                    autoFireBtn.classList.toggle('active', autoFireActive);
                    
                    if (autoFireActive) {
                        // Start auto-firing
                        if (!shootingInterval) {
                            shootingInterval = setInterval(() => {
                                if (socket && player) {
                                    socket.emit("shoot");
                                }
                            }, 180); // Slightly slower than manual for fairness
                        }
                    } else {
                        // Stop auto-firing
                        if (shootingInterval) {
                            clearInterval(shootingInterval);
                            shootingInterval = null;
                        }
                    }
                });
                
                // Movement joystick events
                joystickArea.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    joystickActive = true;
                    
                    const touch = e.touches[0];
                    const rect = joystickArea.getBoundingClientRect();
                    joystickStartPos.x = rect.left + rect.width / 2;
                    joystickStartPos.y = rect.top + rect.height / 2;
                    joystickCurrentPos.x = touch.clientX;
                    joystickCurrentPos.y = touch.clientY;
                    
                    updateJoystickPosition();
                });
                
                joystickArea.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                    if (!joystickActive) return;
                    
                    const touch = e.touches[0];
                    joystickCurrentPos.x = touch.clientX;
                    joystickCurrentPos.y = touch.clientY;
                    
                    updateJoystickPosition();
                });
                
                joystickArea.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    joystickActive = false;
                    
                    // Reset joystick position
                    joystickThumb.style.left = '40px';
                    joystickThumb.style.top = '40px';
                    
                    // Stop movement
                    moveVector.dx = 0;
                    moveVector.dy = 0;
                });
                
                // Aiming/firing events
                fireArea.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    firingActive = true;
                    
                    const touch = e.touches[0];
                    updateFirePosition(touch);
                    
                    // If not in auto-fire mode, start manual firing
                    if (!autoFireActive) {
                        // First shot immediately
                        if (socket && player) {
                            socket.emit("shoot");
                        }
                        
                        // Start continuous firing
                        shootingInterval = setInterval(() => {
                            if (firingActive && socket && player) {
                                socket.emit("shoot");
                            }
                        }, 180);
                    }
                });
                
                fireArea.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                    if (!firingActive) return;
                    
                    const touch = e.touches[0];
                    updateFirePosition(touch);
                });
                
                fireArea.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    firingActive = false;
                    
                    // Reset fire button position
                    fireButton.style.left = '40px';
                    fireButton.style.top = '40px';
                    
                    // Stop manual firing if not in auto-fire mode
                    if (!autoFireActive && shootingInterval) {
                        clearInterval(shootingInterval);
                        shootingInterval = null;
                    }
                });
                
                // Update movement at fixed intervals
                setInterval(() => {
                    if (player && socket && (moveVector.dx !== 0 || moveVector.dy !== 0)) {
                        socket.emit("move", moveVector);
                    }
                }, 33); // ~30 times per second
                
                // Helper functions for mobile controls
                function updateJoystickPosition() {
                    const deltaX = joystickCurrentPos.x - joystickStartPos.x;
                    const deltaY = joystickCurrentPos.y - joystickStartPos.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = joystickArea.clientWidth / 2 - joystickThumb.clientWidth / 2;
                    
                    let thumbX, thumbY;
                    
                    if (distance > maxDistance) {
                        // Limit to edge of joystick area
                        const angle = Math.atan2(deltaY, deltaX);
                        thumbX = Math.cos(angle) * maxDistance + joystickArea.clientWidth / 2 - joystickThumb.clientWidth / 2;
                        thumbY = Math.sin(angle) * maxDistance + joystickArea.clientHeight / 2 - joystickThumb.clientHeight / 2;
                    } else {
                        thumbX = deltaX + joystickArea.clientWidth / 2 - joystickThumb.clientWidth / 2;
                        thumbY = deltaY + joystickArea.clientHeight / 2 - joystickThumb.clientHeight / 2;
                    }
                    
                    // Update joystick thumb position
                    joystickThumb.style.left = thumbX + 'px';
                    joystickThumb.style.top = thumbY + 'px';
                    
                    // Calculate movement vector (-1 to 1 for both axes)
                    moveVector.dx = Math.min(Math.max(deltaX / maxDistance, -1), 1);
                    moveVector.dy = Math.min(Math.max(deltaY / maxDistance, -1), 1);
                }
                
                function updateFirePosition(touch) {
                    const rect = fireArea.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const deltaX = touch.clientX - centerX;
                    const deltaY = touch.clientY - centerY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = fireArea.clientWidth / 2 - fireButton.clientWidth / 2;
                    
                    // Calculate aim angle
                    aimAngle = Math.atan2(deltaY, deltaX);
                    
                    // Send rotation to server
                    if (socket && player) {
                        socket.emit("rotate", aimAngle);
                    }
                    
                    // Update fire button position (visual feedback)
                    let buttonX, buttonY;
                    
                    if (distance > maxDistance) {
                        // Limit to edge of fire area
                        buttonX = Math.cos(aimAngle) * maxDistance + fireArea.clientWidth / 2 - fireButton.clientWidth / 2;
                        buttonY = Math.sin(aimAngle) * maxDistance + fireArea.clientHeight / 2 - fireButton.clientHeight / 2;
                    } else {
                        buttonX = deltaX + fireArea.clientWidth / 2 - fireButton.clientWidth / 2;
                        buttonY = deltaY + fireArea.clientHeight / 2 - fireButton.clientHeight / 2;
                    }
                    
                    fireButton.style.left = buttonX + 'px';
                    fireButton.style.top = buttonY + 'px';
                }
                // Events for death screen
                document.getElementById('death-continue-btn').addEventListener('click', function() {
                    document.body.classList.remove('controls-hidden');
                    location.reload();
                });
                
                // Setup visibility changes
                document.addEventListener('visibilitychange', function() {
                    if (document.hidden) {
                        // Page is hidden (app in background)
                        if (shootingInterval) {
                            clearInterval(shootingInterval);
                            shootingInterval = null;
                        }
                        autoFireActive = false;
                        autoFireBtn.classList.remove('active');
                    }
                });
                
                // Lock screen orientation to landscape if supported
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        screen.orientation.lock('landscape').catch(e => {
                            console.log('Orientation lock not supported:', e);
                        });
                    } catch (e) {
                        console.log('Orientation API not fully supported');
                    }
                }
                
                // Request fullscreen on first touch for better experience
                document.addEventListener('touchstart', function requestFullScreen() {
                    const elem = document.documentElement;
                    
                    if (elem.requestFullscreen) {
                        elem.requestFullscreen().catch(e => {
                            console.log('Fullscreen request denied:', e);
                        });
                    } else if (elem.mozRequestFullScreen) { /* Firefox */
                        elem.mozRequestFullScreen();
                    } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                        elem.webkitRequestFullscreen();
                    } else if (elem.msRequestFullscreen) { /* IE/Edge */
                        elem.msRequestFullscreen();
                    }
                    
                    // Remove this listener after first execution
                    document.removeEventListener('touchstart', requestFullScreen);
                }, { once: true });
            }

            // Vor dem Verlassen der Seite Spieldaten senden
            window.addEventListener('beforeunload', () => {
                if (playerToken && player) {
                    // Sende Spielstatistiken
                    const gameTime = (Date.now() - gameStartTime) / 1000; // in Sekunden

                    // Benutze sendBeacon statt fetch, da es zuverl√§ssiger bei unload events ist
                    navigator.sendBeacon(`https://nm-web.de/game_end.php?token=${playerToken}`, 
                        JSON.stringify({
                            playtime: gameTime,
                            kills: player.kills || 0,
                            max_level: player.level || 1,
                            score: player.score || 0
                        })
                    );
                    
                    // Clear any intervals
                    if (shootingInterval) {
                        clearInterval(shootingInterval);
                    }
                }
            });
            
            // Additional event for mobile devices to handle resize events better
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    particleCanvas.width = window.innerWidth;
                    particleCanvas.height = window.innerHeight;
                    
                    // Readjust camera zoom based on new orientation
                    setCameraZoom();
                }, 100); // Small delay to ensure dimensions are updated
            });
        </script>
    </body>
</html>
